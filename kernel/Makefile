
# run default-host script, set DEFAULT_HOST to the result
# set HOST to this value if it's not already set
# Run script to get host architecture, set HOSTARCH
DEFAULT_HOST!=../default-host.sh
HOST?=DEFAULT_HOST
HOSTARCH!=../target-triplet-to-arch.sh $(HOST)

# Set default Cflags to -O2 -g
CFLAGS?=-O2 -g
CPPFLAGS?=
LDFLAGS?=
LIBS?=

# Use /usr/local as default prefix, exec prefix
# BOOTDIR defaults to /usr/local/boot
# INCLUDEDIR defaults to /usr/local/include
DESTDIR?=
PREFIX?=/usr/local
EXEC_PREFIX?=$(PREFIX)
BOOTDIR?=$(EXEC_PREFIX)/boot
INCLUDEDIR?=$(PREFIX)/include

# Add to CFLAGS: -O2 -g -freestanding -Wall -Wextra
# Set CPPFLAGS if (???)
# LIB does not include standard libs. Has libk and libgcc
CFLAGS:=$(CFLAGS) -ffreestanding -Wall -Wextra
CPPFLAGS:=$(CPPFLAGS) -D__is_kernel -Iinclude
LDFLAGS:=$(LDFLAGS)
LIBS:=$(LIBS) -nostdlib -lk -lgcc

# Architecture-specific dir to arch/[result from above]
ARCHDIR=arch/$(HOSTARCH)

# In this makefile, at this spot copy in the make.config contents
include $(ARCHDIR)/make.config

# These are updated based on the contents of make.config
CFLAGS:=$(CFLAGS) $(KERNEL_ARCH_CFLAGS)
CPPFLAGS:=$(CPPFLAGS) $(KERNEL_ARCH_CPPFLAGS)
LDFLAGS:=$(LDFLAGS) $(KERNEL_ARCH_LDFLAGS)
LIBS:=$(LIBS) $(KERNEL_ARCH_LIBS)

# Updated based on the contents of make.config
# grabs the kernel.o relocatable object file
KERNEL_OBJS=\
$(KERNEL_ARCH_OBJS) \
kernel/kernel.o \

# This grabs all of the object files
OBJS=\
$(ARCHDIR)/crti.o \
$(ARCHDIR)/crtbegin.o \
$(KERNEL_OBJS) \
$(ARCHDIR)/crtend.o \
$(ARCHDIR)/crtn.o \

# This grabs all of the flags and files for linking, in this order
LINK_LIST=\
$(LDFLAGS) \
$(ARCHDIR)/crti.o \
$(ARCHDIR)/crtbegin.o \
$(KERNEL_OBJS) \
$(LIBS) \
$(ARCHDIR)/crtend.o \
$(ARCHDIR)/crtn.o \

# .PHONY makes sure that if there is a file called "clean" e.g.
# that we don't try to build that file, we use our "clean" target
.PHONY: all clean install install-headers install-kernel

# SUFFIXES are used for simple targets
# Essentially, compile foo.c with -c flag, output foo.o
.SUFFIXES: .o .c .S

# generalized way to point to end result target
all: myos.kernel

# Final make target, the kernel
# The entries listed after the colon are the required files
# The actual compilation instruction are the indented following lines
# e.g, after expansion, "i686-elf-gcc -T kernel/arch/i386/linker.ld -o ..."
# Note that we validate the result with --is-x86-multiboot
myos.kernel: $(OBJS) $(ARCHDIR)/linker.ld
	$(CC) -T $(ARCHDIR)/linker.ld -o $@ $(CFLAGS) $(LINK_LIST)
	grub-file --is-x86-multiboot myos.kernel

# Create the crtbegin/crtend files, used for loading main
$(ARCHDIR)/crtbegin.o $(ARCHDIR)/crtend.o:
	OBJ=`$(CC) $(CFLAGS) $(LDFLAGS) -print-file-name=$(@F)` && cp "$$OBJ" $@

# Simple object file transformations, foo.c -> foo.o
.c.o:
	$(CC) -MD -c $< -o $@ -std=gnu11 $(CFLAGS) $(CPPFLAGS)

# Simple compilations for assembly files, foo.S -> foo.o
.S.o:
	$(CC) -MD -c $< -o $@ $(CFLAGS) $(CPPFLAGS)

# Remove compiled files
clean:
	rm -f myos.kernel
	rm -f $(OBJS) *.o */*.o */*/*.o
	rm -f $(OBJS:.o=.d) *.d */*.d */*/*.d

# Call install targets
install: install-headers install-kernel

# Create headers directory, e.g. /sysroot/usr/include
# Copy headers there
install-headers:
	mkdir -p $(DESTDIR)$(INCLUDEDIR)
	cp -R --preserve=timestamps include/. $(DESTDIR)$(INCLUDEDIR)/.

# Create boot directory, e.g. /sysroot/usr/boot
# Copy the kernel there
install-kernel: myos.kernel
	mkdir -p $(DESTDIR)$(BOOTDIR)
	cp myos.kernel $(DESTDIR)$(BOOTDIR)

# Include all of the files in OBJS, with .d extension
# e.g. for foo.o include foo.d
# the "-" before include means a soft dependency, aka don't fail

# A D file is a source dependency file generated by GCC. It contains dependencies
# in plain text that describe the files that were used to create compiled objects (.o files).
# D files are generated automatically when the -MMD flag is activated when compiling.
-include $(OBJS:.o=.d)
